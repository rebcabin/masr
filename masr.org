#+TODO: TODO BACKLOGGED(!) SCHEDULED(!) STARTED(!) SUSPENDED(!) BLOCKED(!) DELEGATED(!) ABANDONED(!) DONE

# FOR DOCUMENTATION OF THESE OPTIONS, see 12.2, Export Settings of the Org Info Manual

#+OPTIONS: ':t                # export smart quotes
#+OPTIONS: *:t                # export emphasized text
#+OPTIONS: -:t                # conversion of special strings
#+OPTIONS: ::t                # fixed-width sections
#+OPTIONS: <:t                # time/date active/inactive stamps
#+OPTIONS: \n:nil             # preserve line breaks
#+OPTIONS: ^:nil              # TeX-like syntax for sub- and super-scripts
#+OPTIONS: arch:headline      # archived trees
#+OPTIONS: author:t           # toggle inclusion of author name on export
#+OPTIONS: broken-links:mark  # ?
#+OPTIONS: c:nil              # clock keywords
#+OPTIONS: creator:nil        # other value is 'comment'

# Exporting of drawers

#+OPTIONS: d:t

# Exporting of drawers to LaTeX is NOT WORKING as of 25 March 2020. The
# workaround is to wrap the drawers in #+begin_example and #+end_example.

# #+OPTIONS: d:("LOGBOOK")      # drawers to include or exclude

#+OPTIONS: date:t             # ?
#+OPTIONS: e:t                # entities
#+OPTIONS: email:nil          # do or don't export my email
#+OPTIONS: f:t                # footnotes
#+OPTIONS: H:3                # number of headline levels to export
#+OPTIONS: inline:t           # export inline tasks?
#+OPTIONS: num:t              # section numbers
#+OPTIONS: p:nil              # toggle export of planning information
#+OPTIONS: pri:nil            # priority cookies
#+OPTIONS: prop:("ATTACH_DIR" "Attachments")           # include property drawers? or list to include?
#+OPTIONS: stat:t             # statistics cookies?
#+OPTIONS: tags:t             # org-export-with-tags? (what's a "tag"?)
#+OPTIONS: tasks:t            # include TODO items ("tasks" some complexity here)
#+OPTIONS: tex:t              # exports inline LaTeX
#+OPTIONS: timestamp:t        # creation timestamp in the exported file?
#+OPTIONS: toc:2              # set level limit in TOC or nil to exclude
#+OPTIONS: todo:t             # inclusion of actual TODO keyword
#+OPTIONS: |:t                # include tables

#+CREATOR: Emacs 26.2 of 2019-04-12, org version: 9.2.2

#+LaTeX_HEADER: \usepackage{bm}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{cmll}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amsthm}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage{mathtools}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage[shortcuts]{extdash}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage[utf8]{inputenc}

# #+LaTeX_HEADER: \usepackage[top=0.90in,bottom=0.55in,left=1.25in,right=1.25in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage[top=1.25in,bottom=1.25in,left=1.75in,right=1.75in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage{palatino}

#+LaTeX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usepackage{braket}
#+LaTeX_HEADER: \usepackage[euler-digits,euler-hat-accent]{eulervm}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \chead{\textbf{(c) Brian Beckman, 2023; Creative Commons Attribution-ShareAlike CC-BY-SA}}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \lfoot{(c) Brian Beckman, 2023; CC-BY-SA}
#+LATEX_HEADER: \cfoot{\thepage}
#+LATEX_HEADER: \rfoot{}
#+LATEX_HEADER: \usepackage{lineno}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{tipa}

# #+LATEX_HEADER: \linenumbers

#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength{\parindent}{15pt}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage[atend]{bookmark}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage[utf8]{inputenc} % usually not needed (loaded by default)
#+LATEX_HEADER: \usepackage[T1]{fontenc}

#+LATEX_HEADER_EXTRA: \BeforeBeginEnvironment{minted}{\begin{mdframed}}
#+LATEX_HEADER_EXTRA: \AfterEndEnvironment{minted}{\end{mdframed}}
#+LATEX_HEADER_EXTRA: \bookmarksetup{open, openlevel=2, numbered}
#+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{03BB}{$\lambda$}
# The following doesn't work: just search replace literal ESC=27=1B with ^[ !
# #+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{001B}{xx}

#                                                    _
#  _ _  _____ __ __  __ ___ _ __  _ __  __ _ _ _  __| |___
# | ' \/ -_) V  V / / _/ _ \ '  \| '  \/ _` | ' \/ _` (_-<
# |_||_\___|\_/\_/  \__\___/_|_|_|_|_|_\__,_|_||_\__,_/__/

#+LaTeX_HEADER: \newcommand\definedas{\stackrel{\text{\tiny def}}{=}}
#+LaTeX_HEADER: \newcommand\belex{BELEX}
#+LaTeX_HEADER: \newcommand\bleir{BLEIR}
#+LaTeX_HEADER: \newcommand\llb{low-level \belex}
#+LaTeX_HEADER: \newcommand\hlb{high-level \belex}
#+LaTeX_HEADER: \newcommand{\Coloneqq}{\mathrel{\vcenter{\hbox{$:\,:\,=$}}{}}}

#+SELECT_TAGS: export
#+STARTUP: indent

#+LaTeX_CLASS_OPTIONS: [10pt,oneside,x11names]
#+MACRO: color \textcolor{$1}{$2}
# Doesn't work: #+MACRO: colorbf \textcolor{$1}{\textbf{$2}}
# Use this instead:
#+LaTeX_HEADER: \newcommand\colorbf[2]{\textcolor{#1}{\textbf{#2}}}

#+LATEX: \setlength\parindent{0pt}

# #+STARTUP: latexpreview inlineimages showall
# #+STARTUP: showall

#+TITLE:  MASR --- Meta Abstract Semantics Representation
#+AUTHOR: Brian Beckman
#+DATE:   10 Apr 2023

#+BEGIN_SRC elisp :exports none
  (setq org-babel-python-command "python3")
  (setq org-image-actual-width nil)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-fontify-natively t)
  (add-to-list 'org-latex-packages-alist '("" "listingsutf8"))
  (setq org-export-latex-listings 'minted)
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-pdf-process
        '("pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-babel-do-load-languages 'org-babel-load-languages
   '((ditaa . t) (latex . t)))
  (princ (concat (format "Emacs version: %s\n" (emacs-version))
                 (format "org version: %s\n" (org-version))))
#+END_SRC

#+RESULTS:
: Emacs version: GNU Emacs 28.2 (build 1, aarch64-apple-darwin21.1.0, NS appkit-2113.00 Version 12.0.1 (Build 21A559))
:  of 2022-09-12
: org version: 9.5.5

\clearpage
* Abstract

Abstract Semantics Representation (ASR) is an
innovative intermediate representation[fn::
https://en.wikipedia.org/wiki/Intermediate_representation]
(IR) for multiple LCompilers.[fn:lcompilers:
https://github.com/lcompilers/libasr] ASR is
independent of the particular programming language
under compilation. Current compiler front-ends
targeting ASR include LFortran[fn::
https://lfortran.org/] and LPython.[fn::
https://lpython.org/] ASR is also agnostic to the
compiler back end. Current back ends targeted /from/
ASR include LLVM, x86, C, and WASM[fn::
https://webassembly.org/]

Being agnostic means that it is easy to write new
compilers, both at the front end and the back end.
For example, LFortran predates LPython. When the
need for a Python compiler arose, only a Python
front end was necessary. Within a few days, a new
end-to-end compiler, LPython, was created.

LCompiler back ends are completely reusable because
ASR eliminates all original language syntax from the
IR, in sharp contrast to typical practice, which
treat semantics as decorations on syntax trees.

In addition to being more flexible, LCompilers are
faster than average because optimizers are not
hampered by useless syntactic structure.

# ASR-to-ASR
# transformations are the magic of LCompilers.
# Optimization, type-checking, partial evaluation,
# abstract execution, and rewriting are examples of
# such transformations.

# ASR is a full programming language in its own
# right, just one with no native syntax,

Current specifications for ASR are written in
ASDL,[fn::
https://en.wikipedia.org/wiki/Abstract-Type_and_Scheme-Definition_Language]
a metalanguage similar in spirit to yacc but less
rich, by design.[fn::
https://en.wikipedia.org/wiki/Yacc] To build an
LCompiler like LFortran or LPython, the ASDL grammar
for ASR is parsed and a library, asrlib, in C++ is
generated. Compiler front ends call this library to
transform and emit ASR trees.

ASDL has several deficiencies, and MASR, [fn::
pronounced "maser;" it is a Physics pun] described
in this document, alleviates them. We aim to replace
asrlib with MASR.

This document is pedagogical, both explaining MASR
and teaching how to extend and maintain its Clojure
code.

* Issues with ASDL

** ASDL is Moribund

ASDL has not progressed since originally published
in 1987. We know of no other projects adopting ASDL.
We should replace ASDL with a modern metalanguage
that has a robust, lively ecosystem.

\newpage
** ASDL is Incomplete

All work with ASR is currently done with opaque
binary representations and code written in C++. As
usual with such, it's more time-consuming and
error-prone than necessary to prototype, verify,
validate, visualize, modify, and debug.

** ASDL is Volatile

The ASDL for ASR changes frequently, for good
reasons. However, stand-aside tools like
asr-tester[fn::
https://github.com/rebcabin/asr-tester] must chase
the ASDL specification. Just keeping up with ASDL
consumes almost all development time for asr-tester.
We should unify the language for expressing ASR with
the tools that verify and test ASR.

** ASDL is Ambiguous

There are many syntactic and semantic ambiguities in
the ASDL grammar. For example, the specification
=integer*= might mean an ordered collection of
=integer= or an unordered collection, with duplicate
elements allowed or not.

ASDL cannot express such distinctions. In practice,
the C++ implementations implicitly make these
distinctions. In one place =integer*= means an
ordered collection. In another place, =integer*=
means an unordered collection, but only the
generated C++ code knows where.

Hiding fine distinctions in specifications in the
generated code is not good engineering practice in
the face of a known better solution.

* Clojure Solves ASDL Issues

ASR expressions, being trees, have a natural
representation in S-Expressions.[fn::
https://en.wikipedia.org/wiki/S-expression] Clojure,
being a modern Lisp, natively handles S-Expressions.
Clojure is modern. Clojure has a robust, lively
ecosystem.
# It is a natural replacement for ASDL.

# In addition to a native fit for data format,
Clojure.spec,[fn:clojure-spec:
https://clojuredocs.org/clojure.spec.alpha] is a
/force majeure/ for precision, completeness,
verification, and validation. The collection of MASR
specs amounts to a meta-type system for ASR.

Clojure specs are arbitrary predicates, capable of
expressing type-system logic beyond typical,
hard-coded type systems. That flexibility affords
new opportunities, say for experiments in dependent
types and concurrency types.[fn::
https://rholang.io/]. In the short run, clojure.spec
will make type constraints for ASDL explicit and
manifest, and will relieve the burden on C++
programmers to manage implicit constraints.

This document may lag the Clojure code. It may also
lag the current state of asrlib, at least until MASR
replaces asrlib. The document mirrors an ASDL
snapshot.[fn::
https://github.com/rebcabin/masr/blob/main/ASR_2023_APR_06_snapshot.asdl]

\clearpage
* MASR Tenets

- Hash-Maps :: --- ASR entities shall be hash-maps
  with fully-qualified keywords as keys (see Section
  [[intent]] for motivating example).

- Multi-Specs :: --- ASR entities shall be
  recursively checked and generated via Clojure
  multi-specs.[fn:multi-spec]

- Explicit :: --- ASR entities shall contain all
  necessary information, even at the cost of
  verbosity. Defaults are not permitted.

- Syntax Sugar :: --- Constructor functions for ASR
  entities may allow default values for keyword
  arguments (see Section [[ttype]] for an example and
  see
  [[https://github.com/rebcabin/masr/issues/3][Issue
  3 on MASR's GitHub repo]].

\clearpage
* MASR Terms and Heads

/Terms/ are the "objects" or "productions" of ASR,
items to the left-hand side of an equals sign in the
ASDL grammar. Table \ref{tbl:terms} exhibits terms
that are

- explicitly specified in ASDL, like =symbol= or
  =dimension=

- used but not defined in ASDL, like =symbol_table=

- term-like but not defined in ASDL, like
  =identifier=

The definitions in Table \ref{tbl:terms} have been
abbreviated and edited for presentation.

#+caption: Terms (nodes) in the ASDL grammar (things left of equals signs):
#+label: tbl:terms
|----+-------------------+------------------------------------------------------------------|
|    | **term**          | **partial expansion**                                            |
|----+-------------------+------------------------------------------------------------------|
|  1 | =unit=            | =TranslationUnit(symbol_table, node*)=                           |
|  2 | =symbol=          | \ldots many heads \ldots                                         |
|  3 | =storage_type=    | =Default= \vert =Save= \vert =Parameter= \vert =Allocatable=     |
|  4 | =access=          | =Public= \vert =Private=                                         |
|  5 | =intent=          | =Local= \vert =In= \vert =Out= \vert =InOut= \vert \ldots        |
|  6 | =deftype=         | =Implementation= \vert =Interface=                               |
|  7 | =presence=        | =Required= \vert =Optional=                                      |
|  8 | =abi=             | =Source= \vert =LFortranModule= \vert \ldots \vert =Intrinsic=   |
|  9 | =stmt=            | \ldots many heads \ldots                                         |
| 10 | =expr=            | \ldots many heads \ldots                                         |
| 11 | =ttype=           | =Integer(int, dimension*)= \vert \ldots                          |
| 12 | =restriction_arg= | =RestrictionArg(= ident =, symbol)=                              |
| 13 | =binop=           | =Add= \vert =Sub= \vert \ldots \vert =BitRShift=                 |
| 14 | =logicalbinop=    | =And= \vert =Or= \vert =Xor= \vert =NEqv= \vert =Eqv=            |
| 15 | =cmpop=           | =Eq= \vert =NotEq= \vert =Lt= \vert =LtE= \vert =Gt= \vert =GtE= |
| 16 | =integerboz=      | =Binary= \vert =Hex= \vert =Octal=                               |
| 17 | =arraybound=      | =LBound= \vert =UBound=                                          |
| 18 | =arraystorage=    | =RowMajor= \vert =ColMajor=                                      |
| 19 | =cast_kind=       | =RealToInteger= \vert =IntegerToReal= \vert \ldots               |
| 20 | =dimension=       | =(expr? start, expr? length)=                                    |
| 21 | =alloc_arg=       | =(expr a, dimension* dims)=                                      |
| 22 | =attribute=       | =Attribute(= ident =name,= attr-arg* =args)=                     |
| 23 | =attribute_arg=   | =(= ident =arg)=                                                 |
| 24 | =call_arg=        | =(expr? value)=                                                  |
| 25 | =tbind=           | =Bind(string lang, string name)=                                 |
| 26 | =array_index=     | =(= expr? =left,= expr? =right,= expr? =step)=                   |
| 27 | =do_loop_head=    | =(= expr? =v,= expr? =start= expr? =end,= expr? =step)=          |
| 28 | =case_stmt=       | =CaseStmt(expr*, stmt*)= \vert \ldots                            |
| 29 | =type_stmt=       | =TypeStmtName(symbol, stmt*)= \vert \ldots                       |
| 30 | =enumtype=        | =IntegerConsecutiveFromZero= \vert \ldots                        |
|----+-------------------+------------------------------------------------------------------|
|    | **implicit**      |                                                                  |
|----+-------------------+------------------------------------------------------------------|
| 31 | =symbol_table=    | Clojure maps                                                     |
| 32 | =symtab_id=       | an =int=                                                         |
|----+-------------------+------------------------------------------------------------------|
|    | **term-like*      |                                                                  |
|----+-------------------+------------------------------------------------------------------|
|  0 | =dimensions=      | =dimension*=, via Clojure vectors or lists                       |
|  0 | atoms             | =int= \vert =float= \vert =bool= \vert =nat= \vert =bignat=      |
|  0 | =identifier=      | by regex                                                         |
|  0 | =identifiers=     | =identifier*=, via Clojure sets                                  |
|----+-------------------+------------------------------------------------------------------|

/Heads/ are things like =Local= and =CaseStmt= that
appear on the right-hand sides of terms equations in
Table \ref{tbl:terms}. There are of two kinds of heads:

- /function-like heads/ :: --- have parentheses and typed
  parameters, \newline e.g., =CaseStmt(expr*, stmt*)=

- /enum-like heads/ :: --- no parentheses, e.g., =Local=

MASR has a Clojure spec and  syntactic sugar for each head.
There are about 250 heads by a recent count.

\newpage
* Specs

The following sections

- summarize the Clojure specs for all ASR terms and heads

- pedagogically explain the architecture and
  approach taken in the Clojure code so that anyone
  may extend and maintain it.

The architecture is the remainder from several
experiments. For example, \linebreak =defrecord= and
=defprotocol= for polymorphism were tried and
discarded in favor of multi-specs.[fn:multi-spec:
https://clojure.org/guides/spec]

The tests in =core_test.clj= exhibit many examples
that pass and, more importantly, fail the specs. We
also keep lightweight, load-time tests inline to the
source file for the specs, =specs.clj=. The balance
between inline tests and separate tests is fluid.

The best way to learn the code is to study the tests
and to run them in the Clojure REPL or in the CIDER
debugger in Emacs.[fn::
https://docs.cider.mx/cider/debugging/debugger.html]

We present the terms somewhat out of the order of
Table \ref{tbl:terms}. First is /intent/, as it is
the archetype for several enum-like terms and heads.

** intent
<<intent>>

*** \colorbf{red}{Sets for Contents}

An ASR /intent/ is one of the symbols

=Local=, =In=, =Out=, =InOut=, =ReturnVar=, =Unspecified=.

The spec for the /contents/ of an intent is simply
this set of enum-like heads. Any Clojure /set/
(e.g., in =#{= \ldots =}= brackets) doubles as a
predicate function for set membership. In
the following two examples, the set appears in the
function position of the usual Clojure function-call
syntax
$\texttt{(}\textit{function} \textit{args}\texttt{*)}$:

If a candidate member is in a set, the result of
calling the set like a function is the candidate
member.

\vskip 0.26cm
#+begin_src clojure :exports both
  (#{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified} 'Local)
#+end_src

#+RESULTS:
: Local

When the candidate element, say =fubar=, is not in the set, the
result is =nil=, which does not print:

\vskip 0.26cm
#+begin_src clojure :exports both
  (#{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified} 'fubar)
#+end_src

#+RESULTS:

Any predicate function can be registered as a
Clojure spec.[fn:clojure-spec] Therefore the spec
for /intent contents/ is just the set of valid
members.

*** \colorbf{red}{Specs have Fully Qualified Keyword Names}

The name of the spec is =::intent-enum=. The double
colon in =::intent-enum= is shorthand. In the file
=specs.clj=, double colon implicitly signifies that
a keyword like =intent-enum= is in the namespace
=masr.specs=. In other files, like =core_test.clj=,
the same keyword is spelled
=:masr.specs/intent-enum=.

The names of all Clojure specs must be
fully qualified in namespaces.

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::intent-enum
    #{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified})
#+end_src

*** \colorbf{red}{How to Use Specs}
<<how-to-use-specs>>

To check an expression like ='Local= against the
=::intent-enum= spec, write

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/valid? ::intent-enum 'Local)
  ;; => true
  (s/valid? ::intent-enum 'fubar)
  ;; => false
#+end_src

To produce conforming or non-conforming (invalid)
entities in other code, write

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/conform ::intent-enum 'Local)
  ;; => Local
  (s/conform ::intent-enum 'fubar)
  ;; => :clojure.spec.alpha/invalid
#+end_src

To generate a few conforming samples, write

\vskip 0.26cm
#+begin_src clojure :eval never
(gen/sample (s/gen ::intent-enum) 5)
;; => (Unspecified Unspecified Out Unspecified Local)
#+end_src

or, with conformance explanation (trivial in this
case):

\vskip 0.26cm
#+begin_src clojure :eval never
(s/exercise ::intent-enum 5)
;; => ([Out Out]
;;     [ReturnVar ReturnVar]
;;     [In In]
;;     [Local Local]
;;     [ReturnVar ReturnVar])
#+end_src

Strip out the conformance information as follows:

\vskip 0.26cm
#+begin_src clojure :eval never
(map second (s/exercise ::intent-enum 5))
;; => (In ReturnVar Out In ReturnVar)
#+end_src

=s/valid?=, =s/conform=, =gen/sample=, and
=s/exercise= pertain to any Clojure specs, no matter
how complex or rich.

*** \colorbf{red}{The Spec that Contains the Contents}

=::intent-enum= is just the spec for the /contents/ of an
intent, not for the intent itself. The spec for the intent
itself is an implementation of a polymorphic Clojure
/multi-spec/[fn:multi-spec], =::asr-term=.

*** \colorbf{red}{Multi-Specs}

A multi-spec is like a tagged union in C. The
multi-spec, =::asr-term=, pertains to all Clojure
hash-maps[fn:hash-map:
https://clojuredocs.org/clojure.core/hash-map] that
have a tag named =::term= with a value like
=::intent= or =::storage-type=, etc. The values, if
themselves fully qualified keywords, are recursively
checked.

A multi-spec has three components:

- =defmulti=[fn:: https://clojuredocs.org/clojure.core/defmulti] :: ---
  a polymorphic interface that declares the
  /tag-fetcher function/, \linebreak =::term= in
  this case. The tag-fetcher function fetches a
  tag's value from any candidate hash-map. The
  =defmulti= dispatches to a =defmethod= that
  matches the fetched tag value, =::intent= in this
  case. =::term= is a fully qualified keyword of
  course, but all keywords double as tag-fetchers
  for hash-maps.[fn::
  https://stackoverflow.com/questions/6915531]

- =defmethod=[fn:: https://clojuredocs.org/clojure.core/defmethod] :: ---
  individual specs, each implementing the interface;
  in this case, if the =::term= of a hash-map
  matches =::intent=, then the corresponding
  =defmethod= is invoked (see Section [[defmethod]] below).

- =s/multi-spec= :: --- tying together the =defmulti= and,
  redundantly, the tag-fetcher.[fn:: Multi-specs allow re-tagging,
  but we do not need that level of generality.]

*** \colorbf{red}{Specs for All Terms}

Start with a spec for =::term=:

\vskip 0.26cm
#+begin_src clojure :eval never
  ;; like ::intent, ::symbol, ::expr, ...
  (s/def ::term qualified-keyword?)
#+end_src

The spec says that any fully qualified keyword, like
=::intent=, is a MASR term. This spec leaves room for
growth of MASR by adding more fully qualified
keywords for more MASR types-/qua/-terms.

=s/def= stands for =clojure.spec.alpha/def=, the
=def= macro in the \linebreak =clojure.spec.alpha=
namespace. The namespace is aliased to =s=.

Next, specify the =defmulti= polymorphic interface,
=term=, (no colons) for all term specs:
# The name of the polymorphic
# interface and also of all =defmethods= that
# implement the interface is =term=, contrast to
# =::term=, the tag-fetcher:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmulti term ::term)
#+end_src

This =defmulti= dispatches to a =defmethod= based on
the results of applying the keyword-/qua/-function
=::term= to a hash-map:

\vskip 0.26cm
#+begin_src clojure :eval never
  (::term {::term ::intent ...})
#+end_src

equals =::intent=.

The spec is named =::term= and the tag-fetcher is named =::term=.
They don't need to be the same. They could have different names.

*** \colorbf{red}{Spec for intent}
<<defmethod>>

If applying =::term= to a Clojure hash-map produces
=::intent=, the following spec, which specifies all
intents, will be invoked. It ignores its
argument, =_=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::intent [_]
    (s/keys :req [::term ::intent-enum]))
#+end_src

This spec states that an /intent/ is a Clojure
hash-map with a =::term= keyword and an
=::intent-enum= keyword.

*** \colorbf{red}{The Multi-Spec Itself: ::asr-term}

=s/multi-spec= ties =defmulti term= to the
tag-fetcher =::term=. The multi-spec itself is named
=::asr-term=:

\vskip 0.26cm
#+begin_src clojure :eval never
  ;;     name of the mult-spec    defmulti  tag fn
  ;;     ------------------------   ----    ------
  (s/def ::asr-term (s/multi-spec   term    ::term))
#+end_src

*** \colorbf{red}{Examples of Intent}
<<examples-of-intent>>

The following shows a valid example:

\vskip 0.26cm
#+begin_src clojure :eval never  :exports both
  (s/valid? ::asr-term
            {::term        ::intent,
             ::intent-enum 'Local})
#+end_src

#+RESULTS:
: true

Here is an invalid sample:

\vskip 0.26cm
#+begin_src clojure :eval never :exports both
  (s/valid? ::asr-term
            {::term        ::intent,
             ::intent-enum 'FooBar})
#+end_src

#+RESULTS:
: false

\newpage
Generate a few valid samples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (gen/sample (s/gen (s/and
                      ::asr/asr-term
                      #(= ::asr/intent (::asr/term %))))
              5)
  ;;=> (#::asr{:term ::asr/intent, :intent-enum ReturnVar}
  ;;    #::asr{:term ::asr/intent, :intent-enum In}
  ;;    #::asr{:term ::asr/intent, :intent-enum Unspecified}
  ;;    #::asr{:term ::asr/intent, :intent-enum Unspecified}
  ;;    #::asr{:term ::asr/intent, :intent-enum InOut})
#+end_src

*** \colorbf{red}{Another asr-term: a Pattern Emerges}

To define another asr-term, specify the contents and
write a =defmethod=. The one multi-spec,
=::asr-term=, suffices for all.

For example, another asr-term for an enum-like is
=storage-type=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::storage-type-enum
    #{'Default, 'Save, 'Parameter, 'Allocatable})

  (defmethod term ::storage-type [_]
    (s/keys :req [::term ::storage-type-enum]))
#+end_src

All enum-like specs follow this pattern.

*** \colorbf{red}{Syntax Sugar}

={::term ::intent, ::intent-enum 'Local}=, a valid
=asr-term= entity, is long and ugly. Write a short
function, =intent=, via =s/conform=, explained in
Section [[how-to-use-specs]]:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn intent [sym]
    (let [intent_ (s/conform
                   ::asr-term
                   {::term ::intent, ::intent-enum sym})]
      (if (s/invalid? intent_)
        ::invalid-intent
        intent_)))
#+end_src

\newpage
Entities have shorter expression with the sugar:

\vskip 0.26cm
#+begin_src clojure :eval never
  (testing "better syntax"
    (is      (s/valid? ::asr-term (intent 'Local)))
    (is      (s/valid? ::asr-term (intent 'Unspecified)))
    (is (not (s/valid? ::asr-term (intent 'foobar))))
    (is (not (s/valid? ::asr-term (intent []))))
    (is (not (s/valid? ::asr-term (intent ()))))
    (is (not (s/valid? ::asr-term (intent {}))))
    (is (not (s/valid? ::asr-term (intent #{}))))
    (is (not (s/valid? ::asr-term (intent "foobar"))))
    (is (not (s/valid? ::asr-term (intent ""))))
    (is (not (s/valid? ::asr-term (intent 42))))
    (is (thrown? clojure.lang.ArityException (intent))))
#+end_src

All our specs are like that: a long-form hash-map and a short-form
sugar function that does a conformance check.

*** \colorbf{red}{Capture the Enum-Like Pattern in a Macro}

All enum-likes have a /contents/ spec, a =defmethod
term=, and a syntax-sugar function. The following
macro pertains to all such enum-like multi-specs:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmacro enum-like [term, heads]
    (let [ns "masr.specs"
          tkw (keyword ns (str term))
          tke (keyword ns (str term "-enum"))
          tki (keyword ns (str "invalid-" term))]
      `(do
         (s/def ~tke ~heads)       ;; the set
         (defmethod term ~tkw [_#] ;; the multi-spec
           (s/keys :req [:masr.specs/term ~tke]))
         (defn ~term [it#]        ;; the syntax
           (let [st# (s/conform
                      :masr.specs/asr-term
                      {:masr.specs/term ~tkw
                       ~tke it#})]
             (if (s/invalid? st#) ~tki, st#))))))
#+end_src

Use the macro like this:

\vskip 0.26cm
#+begin_src clojure :eval never
  (enum-like
   intent
   #{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified})
  (enum-like
   storage-type
   #{'Default, 'Save, 'Parameter, 'Allocatable})
#+end_src

** unit
** symbol

*** TODO Variable

** storage_type
** access
** deftype
** presence

\newpage
** abi
<<abi>>

/Abi/ is a rich case. It is enum-like, similar to
/intent/ (Section [[intent]]), but with restrictions.
Its heads include several /external-abis/:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def external-abis
    #{'LFortranModule, 'GFortranModule,
      'BindC, 'Interactive, 'Intrisic})
#+end_src

and one /internal-abi/, specified as a Clojure set
to get the membership-test functionality:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def internal-abis #{'Source})
#+end_src

The /abi-enum/ spec for the contents of an /abi/
term is the unions of these two sets:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::abi-enum
    (set/union external-abis internal-abis))
#+end_src

Specify an additional key in a conforming /abi/
hash-map with a =::bool= predicate:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::abi-external ::bool)
#+end_src

Add a convenience function for logic:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn iff [a b]
    (or (and a b)
        (not (or a b))))
#+end_src

Specify the =defmethod= for the /abi/ itself with a
hand-written generator (clojure.spec is not quite
strong enough to create the generator automatically):

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::abi [_]
    (s/with-gen
      (s/and
       #(iff (= 'Source (::abi-enum %))
             (not (::abi-external %)))
       (s/keys :req [::term ::abi-enum ::abi-external]))
      (fn []
        (tgen/one-of
         [(tgen/hash-map
           ::term         (gen/return ::abi)
           ::abi-enum     (s/gen external-abis)
           ::abi-external (gen/return true))
          (tgen/hash-map
           ::term         (gen/return ::abi)
           ::abi-enum     (s/gen internal-abis)
           ::abi-external (gen/return false))] ))))
#+end_src

\newpage
Generate a few conforming samples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (gen/sample (s/gen (s/and
                      ::asr/asr-term
                      #(= ::asr/abi (::asr/term %))))
              5)
  ;; => (#::asr{:term ::asr/abi,
  ;;            :abi-enum Interactive, :abi-external true}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Interactive, :abi-external true})
#+end_src

*** \colorbf{red}{Syntax Sugar}


The sugar for /abi/ uses Clojure destructuring[fn::
https://clojure.org/guides/destructuring][fn::
https://gist.github.com/rebcabin/a3c24be3e17135f355348c834ab14141]
for keyword arguments.

Conforming examples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source         :external false)
  (abi 'LFortranModule :external true)
  (abi 'GFortranModule :external true)
  (abi 'BindC          :external true)
  (abi 'Interactive    :external true)
  (abi 'Intrinsic      :external true)
#+end_src

Non-conforming due to incorrect boolean:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source         :external true)
  (abi 'LFortranModule :external false)
  (abi 'GFortranModule :external false)
  (abi 'BindC          :external false)
  (abi 'Interactive    :external false)
  (abi 'Intrinsic      :external false)
#+end_src

\newpage
Non-conforming due to incorrect types or structure:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source :external 42)    ;; types are not ::bool
  (abi 'Source :external "foo") ;;  |
  (abi 'Source :external 'foo)  ;; -=-
  (abi 'Source false) ;; no :external keyword
  (abi 'Source true)  ;;  |
  (abi 'Source 42)    ;;  |
  (abi 'foo true)     ;;  |
  (abi 'foo false)    ;; -=-
#+end_src

We don't show tests of incorrect arity.

Here is the implementation of the sugar, exhibiting
the destructuring technique:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn abi
    "Destructure the keyword :external"
    [the-abi-enum, & {:keys [external]}]
    (let [abi_ (s/conform
                ::asr-term
                {::term ::abi,
                 ::abi-enum the-abi-enum,
                 ::abi-external external})]
      (if (s/invalid? abi_)
        ::invalid-abi
        abi_)))
#+end_src

** stmt
** expr

\clearpage
** ttype
<<ttype>>

Ttype [\emph{sic}] has a nested multi-spec. This is an
archetype for all function-like heads, just as
/intent/ is an archetype for all enum-like heads.

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmulti ttype-head ::ttype-head)
  (defmethod ttype-head ::Integer [_]
    (s/keys :req [::ttype-head ::bytes-kind ::dimensions]))
  (s/def ::asr-ttype-head
    (s/multi-spec ttype-head ::ttype-head))
#+end_src

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::ttype [_]
    (s/keys :req [::term ::asr-ttype-head]))
#+end_src

*** Full Form

One may always write out ttype specs in full:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/valid? ::asr-term
            {::term ::ttype,
             ::asr-ttype-head
             {::ttype-head ::Integer,
              ::bytes-kind 4
              ::dimensions [[6 60] [82]]}})
#+end_src

*** Sugar

Sugar for ttypes comes in two varieties, /light
sugar/ and /full sugar/.
Light sugar require specs with keywords, as in:

\vskip 0.26cm
#+begin_src clojure :eval never
  (ttype (Integer- {:dimensions [], :kind 4}))
  (ttype (Integer- {:kind 4, :dimensions []}))
#+end_src

Full sugar uses positional arguments, as in

\vskip 0.26cm
#+begin_src clojure :eval never
  (ttype (Integer))
  (ttype (Integer 4))
  (ttype (Integer 2 []))
  (ttype (Integer 8 [[6 60] [42]]))
#+end_src

See the tests for many examples.

** restriction_arg
** binop
** logicalbinop
** cmpop
** integerboz
** arraybound
** arraystorage
** cast_kind
** dimension
** alloc_arg
** attribute
** attribute_arg
** call_arg
** tbind
** array_index
** do_loop_head
** case_stmt
** type_stmt
** enumtype

** Implicit Terms

Terms used, explicitly or implicitly,  but not defined in ASDL.

Some items specified in ASDL as /symbol_table/ are actually
/symtab_id/.

*** symtab_id
*** symbol_table

** Term-Like Items

*** dimensions
*** atoms
*** identifier
*** identifiers

* Change Log

2023-06-Apr :: Start.

2023-12-Apr :: enum-like specs
