#+TODO: TODO BACKLOGGED(!) SCHEDULED(!) STARTED(!) SUSPENDED(!) BLOCKED(!) DELEGATED(!) ABANDONED(!) DONE

# FOR DOCUMENTATION OF THESE OPTIONS, see 12.2, Export Settings of the Org Info Manual

#+OPTIONS: ':t                # export smart quotes
#+OPTIONS: *:t                # export emphasized text
#+OPTIONS: -:t                # conversion of special strings
#+OPTIONS: ::t                # fixed-width sections
#+OPTIONS: <:t                # time/date active/inactive stamps
#+OPTIONS: \n:nil             # preserve line breaks
#+OPTIONS: ^:nil              # TeX-like syntax for sub- and super-scripts
#+OPTIONS: arch:headline      # archived trees
#+OPTIONS: author:t           # toggle inclusion of author name on export
#+OPTIONS: broken-links:mark  # ?
#+OPTIONS: c:nil              # clock keywords
#+OPTIONS: creator:nil        # other value is 'comment'

# Exporting of drawers

#+OPTIONS: d:t

# Exporting of drawers to LaTeX is NOT WORKING as of 25 March 2020. The
# workaround is to wrap the drawers in #+begin_example and #+end_example.

# #+OPTIONS: d:("LOGBOOK")      # drawers to include or exclude

#+OPTIONS: date:t             # ?
#+OPTIONS: e:t                # entities
#+OPTIONS: email:nil          # do or don't export my email
#+OPTIONS: f:t                # footnotes
#+OPTIONS: H:3                # number of headline levels to export
#+OPTIONS: inline:t           # export inline tasks?
#+OPTIONS: num:t              # section numbers
#+OPTIONS: p:nil              # toggle export of planning information
#+OPTIONS: pri:nil            # priority cookies
#+OPTIONS: prop:("ATTACH_DIR" "Attachments")           # include property drawers? or list to include?
#+OPTIONS: stat:t             # statistics cookies?
#+OPTIONS: tags:t             # org-export-with-tags? (what's a "tag"?)
#+OPTIONS: tasks:t            # include TODO items ("tasks" some complexity here)
#+OPTIONS: tex:t              # exports inline LaTeX
#+OPTIONS: timestamp:t        # creation timestamp in the exported file?
#+OPTIONS: toc:2              # set level limit in TOC or nil to exclude
#+OPTIONS: todo:t             # inclusion of actual TODO keyword
#+OPTIONS: |:t                # include tables

#+CREATOR: Emacs 26.2 of 2019-04-12, org version: 9.2.2

#+LaTeX_HEADER: \usepackage{bm}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{cmll}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{amsthm}
#+LaTeX_HEADER: \usepackage{amsthm}
#+LaTeX_HEADER: \usepackage{amssymb}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage{mathtools}
#+LaTeX_HEADER: \usepackage{interval}  % must install texlive-full
#+LaTeX_HEADER: \usepackage[shortcuts]{extdash}
#+LaTeX_HEADER: \usepackage{tikz}
#+LaTeX_HEADER: \usepackage[utf8]{inputenc}

# #+LaTeX_HEADER: \usepackage[top=0.90in,bottom=0.55in,left=1.25in,right=1.25in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage[top=1.25in,bottom=1.25in,left=1.75in,right=1.75in,includefoot]{geometry}

#+LaTeX_HEADER: \usepackage{palatino}

#+LaTeX_HEADER: \usepackage{siunitx}
#+LaTeX_HEADER: \usepackage{braket}
#+LaTeX_HEADER: \usepackage[euler-digits,euler-hat-accent]{eulervm}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \pagestyle{fancyplain}
#+LATEX_HEADER: \lhead{}
#+LATEX_HEADER: \chead{\textbf{(c) Brian Beckman, 2023; Creative Commons Attribution-ShareAlike CC-BY-SA}}
#+LATEX_HEADER: \rhead{}
#+LATEX_HEADER: \lfoot{(c) Brian Beckman, 2023; CC-BY-SA}
#+LATEX_HEADER: \cfoot{\thepage}
#+LATEX_HEADER: \rfoot{}
#+LATEX_HEADER: \usepackage{lineno}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{tipa}

# #+LATEX_HEADER: \linenumbers

#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength{\parindent}{15pt}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage[atend]{bookmark}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage[utf8]{inputenc} % usually not needed (loaded by default)
#+LATEX_HEADER: \usepackage[T1]{fontenc}

#+LATEX_HEADER_EXTRA: \BeforeBeginEnvironment{minted}{\begin{mdframed}}
#+LATEX_HEADER_EXTRA: \AfterEndEnvironment{minted}{\end{mdframed}}
#+LATEX_HEADER_EXTRA: \bookmarksetup{open, openlevel=2, numbered}
#+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{03BB}{$\lambda$}
# The following doesn't work: just search replace literal ESC=27=1B with ^[ !
# #+LATEX_HEADER_EXTRA: \DeclareUnicodeCharacter{001B}{xx}

#                                                    _
#  _ _  _____ __ __  __ ___ _ __  _ __  __ _ _ _  __| |___
# | ' \/ -_) V  V / / _/ _ \ '  \| '  \/ _` | ' \/ _` (_-<
# |_||_\___|\_/\_/  \__\___/_|_|_|_|_|_\__,_|_||_\__,_/__/

#+LaTeX_HEADER: \newcommand\definedas{\stackrel{\text{\tiny def}}{=}}
#+LaTeX_HEADER: \newcommand\belex{BELEX}
#+LaTeX_HEADER: \newcommand\bleir{BLEIR}
#+LaTeX_HEADER: \newcommand\llb{low-level \belex}
#+LaTeX_HEADER: \newcommand\hlb{high-level \belex}
#+LaTeX_HEADER: \newcommand{\Coloneqq}{\mathrel{\vcenter{\hbox{$:\,:\,=$}}{}}}

#+LaTeX_HEADER: \theoremstyle{definition}
#+LaTeX_HEADER: \newtheorem{definition}{Definition}

#+LaTeX_HEADER: \theoremstyle{slogan}
#+LaTeX_HEADER: \newtheorem{slogan}{Slogan}

#+LaTeX_HEADER: \theoremstyle{warning}
#+LaTeX_HEADER: \newtheorem{warning}{Warning}

#+LaTeX_HEADER: \theoremstyle{premise}
#+LaTeX_HEADER: \newtheorem{premise}{Premise}

#+SELECT_TAGS: export
#+STARTUP: indent

#+LaTeX_CLASS_OPTIONS: [10pt,oneside,x11names]
#+MACRO: color \textcolor{$1}{$2}
# Doesn't work: #+MACRO: colorbf \textcolor{$1}{\textbf{$2}}
# Use this instead:
#+LaTeX_HEADER: \newcommand\colorbf[2]{\textcolor{#1}{\textbf{#2}}}

#+LATEX: \setlength\parindent{0pt}

# #+STARTUP: latexpreview inlineimages showall
# #+STARTUP: showall

#+TITLE:  MASR --- Meta Abstract Semantics Representation
#+AUTHOR: Brian Beckman
#+DATE:   10 Apr 2023

#+BEGIN_SRC elisp :exports none
  (setq org-babel-python-command "python3")
  (setq org-image-actual-width nil)
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-fontify-natively t)
  (add-to-list 'org-latex-packages-alist '("" "listingsutf8"))
  (setq org-export-latex-listings 'minted)
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-pdf-process
        '("pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex --synctex=1 -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (org-babel-do-load-languages 'org-babel-load-languages
   '((ditaa . t) (latex . t)))
  (princ (concat (format "Emacs version: %s\n" (emacs-version))
                 (format "org version: %s\n" (org-version))))
#+END_SRC

#+RESULTS:
: Emacs version: GNU Emacs 28.2 (build 1, aarch64-apple-darwin21.1.0, NS appkit-2113.00 Version 12.0.1 (Build 21A559))
:  of 2022-09-12
: org version: 9.5.5

\clearpage
* Abstract

Abstract Semantics Representation (ASR) is an
innovative intermediate representation[fn::
https://en.wikipedia.org/wiki/Intermediate_representation]
(IR) for multiple LCompilers.[fn:lcompilers:
https://github.com/lcompilers/libasr] ASR is
independent of the particular programming language
under compilation. Current compiler front-ends
targeting ASR include LFortran[fn::
https://lfortran.org/] and LPython.[fn::
https://lpython.org/] ASR is also agnostic to the
compiler back end. Current back ends targeted /from/
ASR include LLVM, x86, C, and WASM[fn::
https://webassembly.org/]

Being agnostic means that it is easy to write new
compilers, both at the front end and the back end.
For example, LFortran predates LPython. When the
need for a Python compiler arose, only a Python
front end was necessary. Within a few days, a new
end-to-end compiler, LPython, was created.

LCompiler back ends are completely reusable because
ASR eliminates all original language syntax from the
IR, in sharp contrast to typical practice, which
treat semantics as decorations on syntax trees.

In addition to being more flexible, LCompilers are
faster than average because optimizers are not
hampered by useless syntactic structure.

# ASR-to-ASR
# transformations are the magic of LCompilers.
# Optimization, type-checking, partial evaluation,
# abstract execution, and rewriting are examples of
# such transformations.

# ASR is a full programming language in its own
# right, just one with no native syntax,

Current specifications for ASR are written in
ASDL,[fn::
https://en.wikipedia.org/wiki/Abstract-Type_and_Scheme-Definition_Language]
a metalanguage similar in spirit to yacc but less
rich, by design.[fn::
https://en.wikipedia.org/wiki/Yacc] To build an
LCompiler like LFortran or LPython, the ASDL
grammar[fn:grammar-snapshot:
https://github.com/rebcabin/masr/blob/main/ASR_2023_APR_06_snapshot.asdl]
for ASR is parsed, and a library, libasr,[fn:libasr:
https://github.com/lfortran/lfortran/tree/c648a8d824242b676512a038bf2257f3b28dad3b/src/libasr]
in C++, is generated. Compiler front ends call
functions in this library to transform and emit ASR
trees.

ASDL has several deficiencies, and MASR, [fn::
pronounced "maser;" it is a Physics pun] described
in this document, alleviates them. We aim to replace
ASDL with MASR.

This document is pedagogical, both explaining MASR
and teaching how to extend and maintain its Clojure
code.

This document may lag the Clojure code. It may also
lag the current state of libasr, at least until MASR
replaces ASDL. The document mirrors an ASDL
snapshot.[fn:grammar-snapshot]

\clearpage
* Cheat Sheet

The following table summarizes this document with
simple conforming examples via syntactic sugar.
There are other ways to construct conforming
examples, but sugar is the recommended way.

Equally important are non-conforming examples. See
the body of this document, the =tests= in
=specs.clj=, and the =deftest='s in =core_tests.clj=
for non-conforming examples.

All keywords are in namespace =masr.specs=. For
example, =::nat= is short for =:masr.specs/nat=.

| **Spec or Multi-Spec** | **term**         | **Sugared Conforming Example**     |
|------------------------+------------------+------------------------------------|
| =::nat=                | NA               | =(nat 42))=                        |
| =::identifier=         | NA               | =(identifier 'boofar)=             |
| =::identifier-set=     | NA               | =(identifier-set ['a 'a])=         |
| =::identifier-list=    | NA               | =(identifier-list ['a 'a])=        |
| =::identifier-suit=    | NA               | =(identifier-suit ['a 'b])=        |
| =::asr-term=           | =::dimension=    | =(dimension [6 60])=               |
| =::dimensions=         | NA               | =(dimensions [[6 60] [42]])=       |
| =::asr-term=           | =::intent=       | =(intent 'Local)=                  |
| =::asr-term=           | =::storage-type= | =(storage-type 'Default)=          |
| =::asr-term=           | =::abi=          | =(s/conform ::asr-term=            |
|                        |                  | =(  abi 'Source :external false))= |
| =::asr-term=           | =::ttype=        | =(Integer 4 [[6 60] [42]])=        |

\clearpage
* Issues with ASDL
<<issues>>

** ASDL is Moribund

ASDL has not progressed since originally published
in 1987. We know of no other projects adopting ASDL.
We should replace ASDL with a modern metalanguage
that has a robust, lively ecosystem.

** ASDL is Incomplete

Much of the semantics of ASR is currently expressed
only in hand-written C++ code. The reason is that
ASDL is not sufficiently expressive to cover the
needed cases. As usual with such a design, it's more
time-consuming and error-prone than necessary to
prototype, verify, validate, visualize, modify, and
debug. Something more expressive than ASDL is
needed to take some responsibility off of
hand-written C++ code.

** ASDL's ASR is Volatile

The ASDL for ASR changes frequently, for good
reasons. However, stand-aside tools like
asr-tester[fn::
https://github.com/rebcabin/asr-tester] must chase
the specification. Just keeping up with ASR-in-ASDL
consumes almost all development time for asr-tester.
We should unify the language that expresses ASR with
the tools that verify and test ASR.

** ASDL is Ambiguous
<<asdl-is-ambiguous>>

There are many syntactic and semantic ambiguities in
the ASDL grammar.[fn:grammar-snapshot]. For example,
the type notation =integer*= might mean, in one
place in the grammar, a list of =integer= with
duplicate entries allowed, and, in another place in
the grammar, a set of =integer= with duplicate
entries not allowed..

ASDL is not sufficient to express such distinctions.
In practice, the hand-written C++ implementations
implicitly make these distinctions, hiding them from
view and making them difficult to revise. It is bad
practice to hide fine distinctions that have
observable effects in the implementations. Instead,
we should express those distinctions directly in the
specifications. Because ASDL cannot express such
distinctions, we must adopt something more
expressive than ASDL.

# Another kind of ambiguity concerns =symbol_table=.
# In some places in the ASDL
# grammar,[fn:grammar-snapshot] the type
# =symbol_table= means a literal hash-map. In other
# places, =symbol_table= means an integer ID. Only the
# hand-written C++ code knows where.

# That kind of ambiguity is avoidable in ASDL. That
# kind of ambiguity is simply a design flaw in the
# expression of ASR in ASDL.

\clearpage
* Clojure Solves ASDL Issues

ASR expressions, being trees, have a natural
representation in S-Expressions.[fn::
https://en.wikipedia.org/wiki/S-expression] Clojure,
being a modern Lisp, natively handles S-Expressions.
Clojure is modern. Clojure has a robust, lively
ecosystem.

Clojure.spec,[fn:clojure-spec:
https://clojuredocs.org/clojure.spec.alpha] is a
/force majeure/ for precision, completeness,
verification, and validation. The collection of MASR
specs amounts to a meta-type system for ASR.

Clojure specs are arbitrary predicate functions.
Clojure specs can easily express the difference
between /list/ and /set/, solving the ambiguity
issue outlined in Section [[asdl-is-ambiguous]]. Clojure
specs, moreover, can flexibly express type-system
features beyond the logics of typical, hard-coded
type systems. That flexibility affords new long-term
opportunities, say for experiments in dependent
types and concurrency types.[fn::
https://rholang.io/]. In the short run, clojure.spec
will make type constraints for ASDL explicit and
manifest, and will relieve the burden on C++
programmers to manage implicit constraints.

\clearpage
* MASR Definitions

\begin{framed}
\begin{definition}
  A \emph{spec} is a predicate function
  that tests an expression for conformance.
  \emph{Spec} is a synonym for \emph{type}
  in this document.
\end{definition}
\vskip 0.26cm
\end{framed}

\begin{framed}
\begin{definition}
\emph{Terms} are the "objects" or "productions" of ASR,
like $\texttt{symbol}$ or $\texttt{dimension}$.
\end{definition}
\vskip 0.26cm
\end{framed}

Names of terms appear to the left of equals signs in
the ASDL grammar.[fn:grammar-snapshot] Names of
terms are generally in lower-case.

Table \ref{tbl:nodes} exhibits terms, ambiguous
types, and term-like types. Ambiguous types and
term-like types are used but not defined in the ASDL
grammar, but are explicitly defined in MASR.

The ambiguous types, =symbol_table= and =symtab_id=,
are called out. The ASDL grammar conflates these
two, having only =symbol_table= to mean either a
full hash-map entity or an integer ID, depending on
criteria hidden in hand-written C++ code. A primary
objective of MASR is to remove this kind of
ambiguity. This kind of ambiguity is not a
deficiency of ASDL like that explained in Section
[[asdl-is-ambiguous]]. Unlike the difference between a
list and a set, ASDL can express the difference
between a hash-map and an integer ID. The failure to
do so is a design flaw in the current ASDL grammar.

The contents of Table \ref{tbl:nodes} have been
greatly abbreviated and edited for presentation.

\begin{framed}
\begin{definition}
\emph{Heads} are expressions like $\texttt{Local}$
and $\texttt{CaseStmt}$,
generally in PascalCase,
that appear on the right-hand sides of
equals signs in Table \ref{tbl:nodes}.
\end{definition}
\vskip 0.26cm
\end{framed}

See the blog post in the footnote[fn::
https://alok-verma6597.medium.com/case-styles-in-development-camel-pascal-snake-and-kebab-case-ed8e7b2497af]
for an informal description of /PascalCase/.

There are of two kinds of heads:

- /function-like heads/ :: --- have parentheses and typed
  parameters, \newline e.g., =CaseStmt(expr*, stmt*)=

- /enum-like heads/ :: --- no parentheses, e.g., =Local=

MASR has a Clojure spec and syntactic sugar for each
head. There are about 250 heads by a recent count.

\begin{framed}
\begin{definition}
  An \emph{ASR entity} is a compound type like \newline
  $\texttt{CaseStmt(expr*, stmt*)}$, with a function-like head
  and zero-or more arguments, possibly with names, that require recursive conformance.
\end{definition}
\end{framed}

#+caption: Nodes in the ASDL Grammar
#+label: tbl:nodes
|----+-------------------+------------------------------------------------------------------|
|    | **term**          | **partial expansion**                                            |
|----+-------------------+------------------------------------------------------------------|
|  1 | =unit=            | =TranslationUnit(symbol_table, node*)=                           |
|  2 | =symbol=          | \ldots many heads \ldots                                         |
|  3 | =storage_type=    | =Default= \vert =Save= \vert =Parameter= \vert =Allocatable=     |
|  4 | =access=          | =Public= \vert =Private=                                         |
|  5 | =intent=          | =Local= \vert =In= \vert =Out= \vert =InOut= \vert \ldots        |
|  6 | =deftype=         | =Implementation= \vert =Interface=                               |
|  7 | =presence=        | =Required= \vert =Optional=                                      |
|  8 | =abi=             | =Source= \vert =LFortranModule= \vert \ldots \vert =Intrinsic=   |
|  9 | =stmt=            | \ldots many heads \ldots                                         |
| 10 | =expr=            | \ldots many heads \ldots                                         |
| 11 | =ttype=           | =Integer(int, dimension*)= \vert \ldots                          |
| 12 | =restriction_arg= | =RestrictionArg(= ident =, symbol)=                              |
| 13 | =binop=           | =Add= \vert =Sub= \vert \ldots \vert =BitRShift=                 |
| 14 | =logicalbinop=    | =And= \vert =Or= \vert =Xor= \vert =NEqv= \vert =Eqv=            |
| 15 | =cmpop=           | =Eq= \vert =NotEq= \vert =Lt= \vert =LtE= \vert =Gt= \vert =GtE= |
| 16 | =integerboz=      | =Binary= \vert =Hex= \vert =Octal=                               |
| 17 | =arraybound=      | =LBound= \vert =UBound=                                          |
| 18 | =arraystorage=    | =RowMajor= \vert =ColMajor=                                      |
| 19 | =cast_kind=       | =RealToInteger= \vert =IntegerToReal= \vert \ldots               |
| 20 | =dimension=       | =(expr? start, expr? length)=                                    |
| 21 | =alloc_arg=       | =(expr a, dimension* dims)=                                      |
| 22 | =attribute=       | =Attribute(= ident =name,= attr-arg* =args)=                     |
| 23 | =attribute_arg=   | =(= ident =arg)=                                                 |
| 24 | =call_arg=        | =(expr? value)=                                                  |
| 25 | =tbind=           | =Bind(string lang, string name)=                                 |
| 26 | =array_index=     | =(= expr? =left,= expr? =right,= expr? =step)=                   |
| 27 | =do_loop_head=    | =(= expr? =v,= expr? =start= expr? =end,= expr? =step)=          |
| 28 | =case_stmt=       | =CaseStmt(expr*, stmt*)= \vert \ldots                            |
| 29 | =type_stmt=       | =TypeStmtName(symbol, stmt*)= \vert \ldots                       |
| 30 | =enumtype=        | =IntegerConsecutiveFromZero= \vert \ldots                        |
|----+-------------------+------------------------------------------------------------------|
|    | **ambiguous**     |                                                                  |
|----+-------------------+------------------------------------------------------------------|
| 31 | =symbol_table=    | Clojure maps                                                     |
| 32 | =symtab_id=       | =int= (new in MASR; not in ASDL)                                 |
|----+-------------------+------------------------------------------------------------------|
|    | **term-like*      |                                                                  |
|----+-------------------+------------------------------------------------------------------|
|  0 | =dimensions=      | =dimension*=, via Clojure vectors or lists                       |
|  0 | atoms             | =int= \vert =float= \vert =bool= \vert =nat= \vert =bignat=      |
|  0 | =identifier=      | by regex                                                         |
|  0 | =identifiers=     | =identifier*=, via Clojure sets                                  |
|----+-------------------+------------------------------------------------------------------|
#+TBLFM: $3=int= (new in MASR; not in ASDL)

\clearpage
* MASR Tenets

- Entity Hash-Maps :: --- ASR
  entities[fn:clojure-spec-entity:
  https://clojure.org/guides/spec] shall be
  hash-maps with fully-qualified keywords as keys
  (see Section [[intent]] for motivating example).

- Multi-Specs :: --- ASR entity hash-maps shall be
  recursively checked and generated via Clojure
  multi-specs.[fn:clojure-spec-entity]

- Explicit :: --- ASR entity hash-maps shall contain
  all necessary information, even at the cost of
  verbosity. Defaults are not permitted.

- Syntax Sugar :: --- Extra constructor functions
  for ASR entities may allow default values for
  positional and keyword arguments. See Section
  [[ttype]] for an example and see Issue 3 on MASR's
  GitHub repo.[fn::
  https://github.com/rebcabin/masr/issues/3]

\clearpage
* Base Specs

The specs in this section are the /atoms/ in the
/term-like/ grouping in Table \ref{tbl:nodes}

** Atoms: =int=, =float=, =bool=, =nat=

The specs for =int=, =float=, and =bool= are straightforward:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::int   int?)     ;; java.lang.Long
  (s/def ::float float?)
  (s/def ::bool  boolean?)
#+end_src

*** Sugar

We restrict the spec, =nat=, for natural numbers, to /int/,
for practical reasons:

\vskip 0.26cm
#+begin_src clojure :eval never
   (s/def ::nat nat-int?)
   ;; sugar
   (defn nat [it]
     (let [cit (s/conform ::nat it)]
       (if (s/invalid? cit)
         ::invalid-nat
         cit)))
#+end_src

\vskip 0.26cm
#+begin_src clojure :eval never
   (tests
    (s/valid? ::nat (nat 42))                    := true
    (s/valid? ::nat (nat -42))                   := false
    (s/valid? ::nat (nat 0))                     := true
    (s/valid? ::nat (nat 0xFFFFFFFFFFFFFFFF))    := false
    (s/valid? ::nat (nat -0xFFFFFFFFFFFFFFFF))   := false
    (s/valid?
     ::nat
     (nat (unchecked-long 0xFFFFFFFFFFFFFFFF)))  := false
    (s/valid?
     ::nat
     (nat (unchecked-long -0xFFFFFFFFFFFFFFFF))) := true
    (s/valid? ::nat (nat 0x7FFFFFFFFFFFFFFF))    := true)
#+end_src

\newpage
** Notes

A Clojure /int/ is a Java /Long/, with some peculiar
behavior for hex literals.[fn::
https://clojurians.slack.com/archives/C03S1KBA2/p1681690965585429]
The gist is that hex literals for negative numbers
in Clojure must have explicit minus signs, lest they
become =clojure.lang.BigInt=, which we disallow for
dimension ([[dimension]]) and dimensions ([[dimensions]]) in
MASR. To get negative =java.lang.Long=, one
employs Clojure's =unchecked-long=.

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests (unchecked-long 0x8000000000000000)
         := -9223372036854775808
         (unchecked-long 0xFFFFFFFFFFFFFFFF)
         := -1
         (unchecked-long 0x8000000000000000)
         := -0x8000000000000000
         (unchecked-long -0xFFFFFFFFFFFFFFFF)
         := 1)
#+end_src

\clearpage
* Term-Like Nodes

This section of the document exhibits specs for the
/term-like nodes/ in Table \ref{tbl:nodes}: namely
=dimensions= (plural), =identifier=, and
=identifiers=. These are not terms, but share some
similarities with terms. Note carefully the
singulars and plurals in the names of the specs.
=dimension= (singular) is a term and covered in
Section [[dimension]].

** dimensions [\emph{sic}]
<<dimensions>>

A MASR /dimensions/ [\emph{sic}], =dimension*= in
ASDL, is a homogeneous ordered collection (list or
vector) of zero or more dimension instances
([[dimension]]). Because \linebreak =::dimensions=
[\emph{sic}] is not a term, we do not need nested
multi-specs. However, because =::dimension=
[\emph{sic}] is a term, the spec for =::dimensions=
must ensure that the elements of its collection
conform to =::dimension=, which is an =asr-term=
multi-spec. We ensure so with a function that
selects terms that match a given spec, =dimension=
in this case. We may reuse that function in other
specs that represent collections that are not,
themselves, terms.

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn term-selector-spec [kwd]
    (s/and ::asr-term
           #(= kwd (::term %))))
#+end_src

(The notation =#(...%...)= is Clojure shorthand for
an anonymous function (lambda) with a positional
argument denoted by =%=, and positional arguments
=%1, %2, ...= when there are two or more arguments.
Applying a keyword like =::term= as a function picks
that keyword out of its hash-map argument.)

Here is the spec, =::dimensions=, for dimensions. We
limit the number of dimensions to 9 for practical
reasons. The meaning of a =::dimensions= instance
with 0 dimensions is an open question (Issue
6[fn:issue6]).

\vskip 0.26cm
#+begin_src clojure :eval never
  (def MIN-NUMBER-OF-DIMENSIONS 0)  ;; TODO: 1?
  (def MAX-NUMBER-OF-DIMENSIONS 9)

  (s/def ::dimensions
    (s/coll-of (term-selector-spec ::dimension)
               :min-count MIN-NUMBER-OF-DIMENSIONS,
               :max-count MAX-NUMBER-OF-DIMENSIONS,
               :into []))
#+end_src

\newpage
*** FullForm

The following tests show a couple of ways of writing
out a =::dimensions= instance in full-form. The
first is necessary in files other than =specs.clj=,
say in =core_tests.clj=. The second can be used in
=specs.clj=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests (s/valid?
          ::dimensions
          [#:masr.specs{:term :masr.specs/dimension,
                        :dimension-content [1 60]}
           #:masr.specs{:term :masr.specs/dimension,
                        :dimension-content ()}]) := true
         (s/valid?
          ::dimensions
          [{::term ::dimension,
            ::dimension-content [1 60]}
           {::term ::dimension,
            ::dimension-content ()}])            := true)
#+end_src

*** Sugar

The following tests illustrate the sugar for
=::dimensions=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (s/valid? ::dimensions [])                        := true
   (s/valid? ::dimensions
             [(dimension '(1 60)) (dimension '())])  := true
   (s/conform ::dimensions
              [(dimension '(1 60)) (dimension '())]) :=
   [#:masr.specs{:term :masr.specs/dimension,
                 :dimension-content [1 60]}
    #:masr.specs{:term :masr.specs/dimension,
                 :dimension-content ()}])
#+end_src

\clearpage
** identifier  [\emph{sic}]

An ASR identifier is a C or Fortran identifier,
which begins with an alphabetic glyph or an
underscore, and has alpha-numeric characters or
underscores following. The only complication in the
spec is the need to generate instances via
=s/with-gen=. The spec solves the generation problem
for identifiers, plus shows a pattern for other
specs that need custom generators.

\vskip 0.26cm
#+begin_src clojure :eval never
  (let [alpha-re #"[a-zA-Z_]"  ;; "let over lambda."
        alphameric-re #"[a-zA-Z0-9_]*"]
    (def alpha?
      #(re-matches alpha-re %))
    (def alphameric?
      #(re-matches alphameric-re %))
    (defn identifier? [sy]
      ;; exclude strings, numbers, quoted numbers
      (and (symbol? sy)
           (let [s (str sy)]
             (and (alpha? (subs s 0 1))
                  (alphameric? (subs s 1))))))
    (def identifier-generator
      (tgen/let [c (gen/char-alpha)
                 s (gen/string-alphanumeric)]
        (symbol (str c s))))
    (s/def ::identifier
      (s/with-gen
        identifier?
        ;; fn wrapping a macro:
        (fn [] identifier-generator))))
#+end_src

The following tests illustrate validation and
generation:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (s/valid? :masr.specs/identifier 'foobar)  := true
   (s/valid? :masr.specs/identifier '_f__547) := true
   (s/valid? :masr.specs/identifier '1234)    := false)
  #_
  (gen/sample (s/gen :masr.specs/identifier))
  ;; => (e c Q G Z2qP fXzg1 sRx2J6 YIhKlV k6 f7k1Xl4)
  ;; => (k hM LV QWC qW0X RGk3u W Kg6X Q2YvFO621 ODUt9)
#+end_src

\newpage
*** Sugar

We define a simple function for creating conforming
identifiers and illustrate it with a couple of
tests:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn identifier [sym]
    (let [csym (s/conform ::identifier sym)]
      (if (s/invalid? csym)
        ::invalid-identifier
        csym)))
  (tests
   (identifier 'foo) := 'foo
   (identifier 123)  := ::invalid-identifier)
#+end_src

\clearpage
** identifiers [\emph{sic}]

ASDL =identifier*= is ambiguous. There are three
kinds of identifier collections in MASR:[fn::
https://github.com/rebcabin/masr/issues/1]

- identifier-set  :: --- unordered, no duplicates

- identifier-list :: --- ordered, duplicates allowed
  (we use vector)

- identifier-suit :: --- ordered, duplicates not
  allowed

For all three kinds, we limit the number of
identifiers to 99 for practical purposes:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def MIN-NUMBER-OF-IDENTIFIERS  0)
  (def MAX-NUMBER-OF-IDENTIFIERS 99)
#+end_src

*** identifier-set

The spec for a set of identifiers is
straightforward because of Clojure's literal syntax,
=#{\ldots}=, for sets, including the empty set:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::identifier-set
    (s/coll-of ::identifier
               :min-count MIN-NUMBER-OF-IDENTIFIERS,
               :max-count MAX-NUMBER-OF-IDENTIFIERS,
               :into #{})) ;; empty set
#+end_src

See the code for uninteresting details of the
sugar-function, =identifier-set=. The following
tests show it at work:

\vskip 0.26cm
#+begin_src clojure :eval never
(tests
 (let [x (identifier-set ['a 'a])]
   (s/valid? ::identifier-set x) := true
   (set?  x)                     := true
   (count x)                     := 1)
 (let [x (identifier-set [])]
   (s/valid? ::identifier-set x) := true
   (set?  x)                     := true
   (count x)                     := 0)
 (let [x (identifier-set ['a '1])]
   (s/valid? ::identifier-set x) := false
   x := ::invalid-identifier-set))
#+end_src

\newpage
*** identifier-list

The spec for a list of identifiers is almost the
same as the spec for a set of identifiers. It
differs only in the =:into= clause --- into a vector
rather than into a set:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::identifier-list
    (s/coll-of ::identifier
               :min-count MIN-NUMBER-OF-IDENTIFIERS,
               :max-count MAX-NUMBER-OF-IDENTIFIERS,
               :into []))
  (tests
   (every? vector? (gen/sample
                    (s/gen ::identifier-list))) := true)
#+end_src

The implementation of the sugar-function for
identifier-list is uninteresting. The following
tests show it at work:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (let [x (identifier-list ['a 'a])]
     (s/valid? ::identifier-list x) := true
     (vector? x)                    := true
     (count   x)                    := 2)
   (let [x (identifier-list [])]
     (s/valid? ::identifier-list x) := true
     (vector? x)                    := true
     (count   x)                    := 0)
   (let [x (identifier-list ['a '1])]
     (s/valid? ::identifier-list x) := false
     x := ::invalid-identifier-list))
#+end_src

\newpage
*** identifier-suit

The spec for an identifier-suit is almost the same
as for identifier-list, only checking that there are
no duplicate elements

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::identifier-suit
    (s/and
     (s/coll-of ::identifier
                :min-count MIN-NUMBER-OF-IDENTIFIERS,
                :max-count MAX-NUMBER-OF-IDENTIFIERS,
                :into [])
     ;; no duplicates
     #(= (count %) (count (set %)))))
#+end_src

Here are the tests for the (uninteresting)
sugar-function:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (let [x (identifier-suit ['a 'a])]
     (s/valid? ::identifier-suit x) := false
     (vector? x)                    := false)
   (let [x (identifier-suit ['a 'b])]
     (s/valid? ::identifier-suit x) := true
     (vector? x)                    := true
     (count   x)                    := 2)
   (let [x (identifier-suit [])]
     (s/valid? ::identifier-suit x) := true
     (vector? x)                    := true
     (count   x)                    := 0)
   (let [x (identifier-suit ['a '1])]
     (s/valid? ::identifier-suit x) := false
     x := ::invalid-identifier-suit))
#+end_src

\clearpage
* Specs

The following sections

- summarize the Clojure specs for all ASR terms and
  heads

- pedagogically explain the architecture and
  approach taken in the Clojure code so that anyone
  may extend and maintain it.

The architecture is the remainder from several
experiments. For example, \linebreak =defrecord= and
=defprotocol= for polymorphism were tried and
discarded in favor of multi-specs.[fn:clojure-spec-entity]

The tests in =core_test.clj= exhibit many examples
that pass and, more importantly, fail the specs. We
also keep lightweight, load-time tests inline to the
source file for the specs, =specs.clj=. The balance
between inline tests and separate tests is fluid.

The best way to learn the code is to study the tests
and to run them in the Clojure REPL or in the CIDER
debugger in Emacs.[fn::
https://docs.cider.mx/cider/debugging/debugger.html]

We present the terms somewhat out of the order of
Table \ref{tbl:nodes}. First is /intent/, as it is
the archetype for several enum-like terms and heads.

** intent
<<intent>>

*** \colorbf{red}{Sets for Contents}

An ASR /intent/ is one of the symbols

=Local=, =In=, =Out=, =InOut=, =ReturnVar=, =Unspecified=.

The spec for the /contents/ of an intent is simply
this set of enum-like heads. Any Clojure /set/
(e.g., in =#{= \ldots =}= brackets) doubles as a
predicate function for set membership. In
the following two examples, the set appears in the
function position of the usual Clojure function-call
syntax
$\texttt{(}\textit{function} \textit{args}\texttt{*)}$:

If a candidate member is in a set, the result of
calling the set like a function is the candidate
member.

\vskip 0.26cm
#+begin_src clojure :exports both
  (#{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified} 'Local)
#+end_src

#+RESULTS:
: Local

When the candidate element, say =fubar=, is not in the set, the
result is =nil=, which does not print:

\vskip 0.26cm
#+begin_src clojure :exports both
  (#{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified} 'fubar)
#+end_src

#+RESULTS:

Any predicate function can be registered as a
Clojure spec.[fn:clojure-spec] Therefore the spec
for /intent contents/ is just the set of valid
members.

*** \colorbf{red}{Specs have Fully Qualified Keyword Names}

The name of the spec is =::intent-enum=. The double
colon in =::intent-enum= is shorthand. In the file
=specs.clj=, double colon implicitly signifies that
a keyword like =intent-enum= is in the namespace
=masr.specs=. In other files, like =core_test.clj=,
the same keyword is spelled
=:masr.specs/intent-enum=.

The names of all Clojure specs must be
fully qualified in namespaces.

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::intent-enum
    #{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified})
#+end_src

*** \colorbf{red}{How to Use Specs}
<<how-to-use-specs>>

To check an expression like ='Local= against the
=::intent-enum= spec, write

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/valid? ::intent-enum 'Local)
  ;; => true
  (s/valid? ::intent-enum 'fubar)
  ;; => false
#+end_src

To produce conforming or non-conforming (invalid)
entities in other code, write

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/conform ::intent-enum 'Local)
  ;; => Local
  (s/conform ::intent-enum 'fubar)
  ;; => :clojure.spec.alpha/invalid
#+end_src

To generate a few conforming samples, write

\vskip 0.26cm
#+begin_src clojure :eval never
(gen/sample (s/gen ::intent-enum) 5)
;; => (Unspecified Unspecified Out Unspecified Local)
#+end_src

or, with conformance explanation (trivial in this
case):

\vskip 0.26cm
#+begin_src clojure :eval never
(s/exercise ::intent-enum 5)
;; => ([Out Out]
;;     [ReturnVar ReturnVar]
;;     [In In]
;;     [Local Local]
;;     [ReturnVar ReturnVar])
#+end_src

Strip out the conformance information as follows:

\vskip 0.26cm
#+begin_src clojure :eval never
(map second (s/exercise ::intent-enum 5))
;; => (In ReturnVar Out In ReturnVar)
#+end_src

=s/valid?=, =s/conform=, =gen/sample=, and
=s/exercise= pertain to any Clojure specs, no matter
how complex or rich.

*** \colorbf{red}{The Spec that Contains the Contents}

=::intent-enum= is just the spec for the /contents/ of an
intent, not for the intent itself. The spec for the intent
itself is an implementation of a polymorphic Clojure
/multi-spec/,[fn:clojure-spec-entity] =::asr-term=.

*** \colorbf{red}{Multi-Specs}

A multi-spec is like a tagged union in C. The
multi-spec, =::asr-term=, pertains to all Clojure
hash-maps[fn:hash-map:
https://clojuredocs.org/clojure.core/hash-map] that
have a tag named =::term= with a value like
=::intent= or =::storage-type=, etc. The values, if
themselves fully qualified keywords, are recursively
checked.

A multi-spec has three components:

- =defmulti=[fn:: https://clojuredocs.org/clojure.core/defmulti] :: ---
  a polymorphic interface that declares the
  /tag-fetcher function/, \linebreak =::term= in
  this case. The tag-fetcher function fetches a
  tag's value from any candidate hash-map. The
  =defmulti= dispatches to a =defmethod= that
  matches the fetched tag value, =::intent= in this
  case. =::term= is a fully qualified keyword of
  course, but all keywords double as tag-fetchers
  for hash-maps.[fn::
  https://stackoverflow.com/questions/6915531]

- =defmethod=[fn:: https://clojuredocs.org/clojure.core/defmethod] :: ---
  individual specs, each implementing the interface;
  in this case, if the =::term= of a hash-map
  matches =::intent=, then the corresponding
  =defmethod= is invoked (see Section [[defmethod]] below).

- =s/multi-spec= :: --- tying together the =defmulti= and,
  redundantly, the tag-fetcher.[fn:: Multi-specs allow re-tagging,
  but we do not need that level of generality.]

*** \colorbf{red}{Specs for All Terms}

Start with a spec for =::term=:

\vskip 0.26cm
#+begin_src clojure :eval never
  ;; like ::intent, ::symbol, ::expr, ...
  (s/def ::term qualified-keyword?)
#+end_src

The spec says that any fully qualified keyword, like
=::intent=, is a MASR term. This spec leaves room for
growth of MASR by adding more fully qualified
keywords for more MASR types-/qua/-terms.

=s/def= stands for =clojure.spec.alpha/def=, the
=def= macro in the \linebreak =clojure.spec.alpha=
namespace. The namespace is aliased to =s=.

Next, specify the =defmulti= polymorphic interface,
=term=, (no colons) for all term specs:
# The name of the polymorphic
# interface and also of all =defmethods= that
# implement the interface is =term=, contrast to
# =::term=, the tag-fetcher:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmulti term ::term)
#+end_src

This =defmulti= dispatches to a =defmethod= based on
the results of applying the keyword-/qua/-function
=::term= to a hash-map:

\vskip 0.26cm
#+begin_src clojure :eval never
  (::term {::term ::intent ...})
#+end_src

equals =::intent=.

The spec is named =::term= and the tag-fetcher is named =::term=.
They don't need to be the same. They could have different names.

*** \colorbf{red}{Spec for intent}
<<defmethod>>

If applying =::term= to a Clojure hash-map produces
=::intent=, the following spec, which specifies all
intents, will be invoked. It ignores its
argument, =_=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::intent [_]
    (s/keys :req [::term ::intent-enum]))
#+end_src

This spec states that an /intent/ is a Clojure
hash-map with a =::term= keyword and an
=::intent-enum= keyword.

*** \colorbf{red}{The Multi-Spec Itself: ::asr-term}

=s/multi-spec= ties =defmulti term= to the
tag-fetcher =::term=. The multi-spec itself is named
=::asr-term=:

\vskip 0.26cm
#+begin_src clojure :eval never
  ;;     name of the mult-spec    defmulti  tag fn
  ;;     ------------------------   ----    ------
  (s/def ::asr-term (s/multi-spec   term    ::term))
#+end_src

*** \colorbf{red}{Examples of Intent}
<<examples-of-intent>>

The following shows a valid example:

\vskip 0.26cm
#+begin_src clojure :eval never  :exports both
  (s/valid? ::asr-term
            {::term        ::intent,
             ::intent-enum 'Local})
#+end_src

#+RESULTS:
: true

Here is an invalid sample:

\vskip 0.26cm
#+begin_src clojure :eval never :exports both
  (s/valid? ::asr-term
            {::term        ::intent,
             ::intent-enum 'FooBar})
#+end_src

#+RESULTS:
: false

\newpage
Generate a few valid samples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (gen/sample (s/gen (s/and
                      ::asr/asr-term
                      #(= ::asr/intent (::asr/term %))))
              5)
  ;;=> (#::asr{:term ::asr/intent, :intent-enum ReturnVar}
  ;;    #::asr{:term ::asr/intent, :intent-enum In}
  ;;    #::asr{:term ::asr/intent, :intent-enum Unspecified}
  ;;    #::asr{:term ::asr/intent, :intent-enum Unspecified}
  ;;    #::asr{:term ::asr/intent, :intent-enum InOut})
#+end_src

*** \colorbf{red}{Another asr-term: a Pattern Emerges}

To define another asr-term, specify the contents and
write a =defmethod=. The one multi-spec,
=::asr-term=, suffices for all.

For example, another asr-term for an enum-like is
=storage-type=:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::storage-type-enum
    #{'Default, 'Save, 'Parameter, 'Allocatable})

  (defmethod term ::storage-type [_]
    (s/keys :req [::term ::storage-type-enum]))
#+end_src

All enum-like specs follow this pattern.

*** \colorbf{red}{Syntax Sugar}

={::term ::intent, ::intent-enum 'Local}=, a valid
=asr-term= entity, is long and ugly. Write a short
function, =intent=, via =s/conform=, explained in
Section [[how-to-use-specs]]:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn intent [sym]
    (let [intent_ (s/conform
                   ::asr-term
                   {::term ::intent, ::intent-enum sym})]
      (if (s/invalid? intent_)
        ::invalid-intent
        intent_)))
#+end_src

\newpage
Entities have shorter expression with the sugar:

\vskip 0.26cm
#+begin_src clojure :eval never
  (testing "better syntax"
    (is      (s/valid? ::asr-term (intent 'Local)))
    (is      (s/valid? ::asr-term (intent 'Unspecified)))
    (is (not (s/valid? ::asr-term (intent 'foobar))))
    (is (not (s/valid? ::asr-term (intent []))))
    (is (not (s/valid? ::asr-term (intent ()))))
    (is (not (s/valid? ::asr-term (intent {}))))
    (is (not (s/valid? ::asr-term (intent #{}))))
    (is (not (s/valid? ::asr-term (intent "foobar"))))
    (is (not (s/valid? ::asr-term (intent ""))))
    (is (not (s/valid? ::asr-term (intent 42))))
    (is (thrown? clojure.lang.ArityException (intent))))
#+end_src

All our specs are like that: a long-form hash-map and a short-form
sugar function that does a conformance check.

*** \colorbf{red}{Capture the Enum-Like Pattern in a Macro}

All enum-likes have a /contents/ spec, a =defmethod
term=, and a syntax-sugar function. The following
macro pertains to all such enum-like multi-specs:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmacro enum-like [term, heads]
    (let [ns "masr.specs"
          tkw (keyword ns (str term))
          tke (keyword ns (str term "-enum"))
          tki (keyword ns (str "invalid-" term))]
      `(do
         (s/def ~tke ~heads)       ;; the set
         (defmethod term ~tkw [_#] ;; the multi-spec
           (s/keys :req [:masr.specs/term ~tke]))
         (defn ~term [it#]        ;; the syntax
           (let [st# (s/conform
                      :masr.specs/asr-term
                      {:masr.specs/term ~tkw
                       ~tke it#})]
             (if (s/invalid? st#) ~tki, st#))))))
#+end_src

Use the macro like this:

\vskip 0.26cm
#+begin_src clojure :eval never
  (enum-like
   intent
   #{'Local 'In 'Out 'InOut 'ReturnVar 'Unspecified})
  (enum-like
   storage-type
   #{'Default, 'Save, 'Parameter, 'Allocatable})
#+end_src

** unit
** symbol

*** TODO Variable

** storage_type
** access
** deftype
** presence

\newpage
** abi
<<abi>>

/Abi/ is a rich case. It is enum-like, similar to
/intent/ (Section [[intent]]), but with restrictions.
Its heads include several /external-abis/:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def external-abis
    #{'LFortranModule, 'GFortranModule,
      'BindC, 'Interactive, 'Intrisic})
#+end_src

and one /internal-abi/, specified as a Clojure set
to get the membership-test functionality:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def internal-abis #{'Source})
#+end_src

The /abi-enum/ spec for the contents of an /abi/
term is the unions of these two sets:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::abi-enum
    (set/union external-abis internal-abis))
#+end_src

Specify an additional key in a conforming /abi/
hash-map with a =::bool= predicate:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/def ::abi-external ::bool)
#+end_src

Add a convenience function for logic:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn iff [a b]
    (or (and a b)
        (not (or a b))))
#+end_src

Specify the =defmethod= for the /abi/ itself with a
hand-written generator (clojure.spec is not quite
strong enough to create the generator automatically):

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::abi [_]
    (s/with-gen
      (s/and
       #(iff (= 'Source (::abi-enum %))
             (not (::abi-external %)))
       (s/keys :req [::term ::abi-enum ::abi-external]))
      (fn []
        (tgen/one-of
         [(tgen/hash-map
           ::term         (gen/return ::abi)
           ::abi-enum     (s/gen external-abis)
           ::abi-external (gen/return true))
          (tgen/hash-map
           ::term         (gen/return ::abi)
           ::abi-enum     (s/gen internal-abis)
           ::abi-external (gen/return false))] ))))
#+end_src

\newpage
Generate a few conforming samples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (gen/sample (s/gen (s/and
                      ::asr/asr-term
                      #(= ::asr/abi (::asr/term %))))
              5)
  ;; => (#::asr{:term ::asr/abi,
  ;;            :abi-enum Interactive, :abi-external true}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Source, :abi-external false}
  ;;     #::asr{:term ::asr/abi,
  ;;            :abi-enum Interactive, :abi-external true})
#+end_src

*** \colorbf{red}{Syntax Sugar}


The sugar for /abi/ uses Clojure destructuring[fn::
https://clojure.org/guides/destructuring][fn::
https://gist.github.com/rebcabin/a3c24be3e17135f355348c834ab14141]
for keyword arguments.

Conforming examples:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source         :external false)
  (abi 'LFortranModule :external true)
  (abi 'GFortranModule :external true)
  (abi 'BindC          :external true)
  (abi 'Interactive    :external true)
  (abi 'Intrinsic      :external true)
#+end_src

Non-conforming due to incorrect boolean:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source         :external true)
  (abi 'LFortranModule :external false)
  (abi 'GFortranModule :external false)
  (abi 'BindC          :external false)
  (abi 'Interactive    :external false)
  (abi 'Intrinsic      :external false)
#+end_src

\newpage
Non-conforming due to incorrect types or structure:

\vskip 0.26cm
#+begin_src clojure :eval never
  (abi 'Source :external 42)    ;; types are not ::bool
  (abi 'Source :external "foo") ;;  |
  (abi 'Source :external 'foo)  ;; -=-
  (abi 'Source false) ;; no :external keyword
  (abi 'Source true)  ;;  |
  (abi 'Source 42)    ;;  |
  (abi 'foo true)     ;;  |
  (abi 'foo false)    ;; -=-
#+end_src

We don't show tests of incorrect arity.

Here is the implementation of the sugar, exhibiting
the destructuring technique:

\vskip 0.26cm
#+begin_src clojure :eval never
  (defn abi
    "Destructure the keyword :external"
    [the-abi-enum, & {:keys [external]}]
    (let [abi_ (s/conform
                ::asr-term
                {::term ::abi,
                 ::abi-enum the-abi-enum,
                 ::abi-external external})]
      (if (s/invalid? abi_)
        ::invalid-abi
        abi_)))
#+end_src

** stmt
** expr

\clearpage
** ttype
<<ttype>>

Ttype [\emph{sic}] has a nested multi-spec. Ttype is
an archetype for all function-like heads, just as
/intent/ is an archetype for all enum-like heads.

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmulti ttype-head ::ttype-head)
  (defmethod ttype-head ::Integer [_]
    (s/keys :req [::ttype-head ::bytes-kind ::dimensions]))
  (s/def ::asr-ttype-head
    (s/multi-spec ttype-head ::ttype-head))
#+end_src

\vskip 0.26cm
#+begin_src clojure :eval never
  (defmethod term ::ttype [_]
    (s/keys :req [::term ::asr-ttype-head]))
#+end_src

*** Full Form

One may always write out ttype specs in full:

\vskip 0.26cm
#+begin_src clojure :eval never
  (s/valid? ::asr-term
            {::term ::ttype,
             ::asr-ttype-head
             {::ttype-head ::Integer,
              ::bytes-kind 4
              ::dimensions [[6 60] [82]]}})
#+end_src

*** Sugar for Integer, Real, Complex, Logical

Sugar for ttypes comes in two varieties, /light
sugar/ and /full sugar/. Names for light-sugar specs
have trailing hyphens. Light sugar requires specs
with keywords, as in:

\vskip 0.26cm
#+begin_src clojure :eval never
  (ttype (Integer- {:dimensions [], :kind 4}))
  (ttype (Integer- {:kind 4, :dimensions []}))
#+end_src

Names for full-sugar specs do not have trailing
hyphens. Full sugar uses positional arguments, as in

\vskip 0.26cm
#+begin_src clojure :eval never
  (ttype (Integer))
  (ttype (Integer 4))
  (ttype (Integer 2 []))
  (ttype (Integer 8 [[6 60] [42]]))
#+end_src

See the tests for many examples.

*** TODO Character

** restriction_arg
** binop
** logicalbinop
** cmpop
** integerboz
** arraybound
** arraystorage
** cast_kind

\clearpage
** dimension
<<dimension>>

A /dimension/ is 0, 1, or 2 nats in a Clojure list
or vector:

\vskip 0.26cm
#+begin_src clojure :eval never
  (def MIN-DIMENSION-COUNT 0)
  (def MAX-DIMENSION-COUNT 2)
  (s/def ::dimension-content
    (s/coll-of ::nat
               :min-count MIN-DIMENSION-COUNT,
               :max-count MAX-DIMENSION-COUNT,
               :into ()))
#+end_src

If there is one nat, it specifies the length of any
array dimension that enjoys the instance. For
example, in the ttype =(Integer 4 [[42]])= ([[ttype]]) ,
the one dimension in the dimensions [\emph{sic}]
([[dimensions]]) of the ttype is =[42]=. The ttype
specifies a rank-1 array of 42 4-byte integers, with
indices starting at 1 and running \linebreak
through 42.

If there are two nats, the first nat specifies the
starting index of any array dimension that enjoys
the instance, and the second nat specifies the
length. For example, in the ttype
=(Integer 4 [[6 60]])= ([[ttype]]), the one dimension in
the dimensions [\emph{sic}] ([[dimensions]]) of the
ttype is =[6 60]=. The ttype specifies a rank-1
array of 60 4-byte integers with indices starting at
6 and running through 65.

If there are no nats, i.e., the array dimension of
any array enjoying the instance is **unspecified**.
For an example, consider the ttype
=(Integer 4 [[]])= ([[ttype]]). This unspecified type is
an open question, Issue 6.[fn:issue6] Also
unspecified is a dimension of zero length.[fn:issue7]

*** TODO: Issue 6: Empty Dimension

See Issue 6 in MASR's GitHub repo[fn:issue6:
https://github.com/rebcabin/masr/issues/6] for
discussion of the meaning of \linebreak
=(Integer 4 [[]])=. Empty dimensions [\emph{sic}],
as in =(Integer 4 [])=, are also unspecified and
further discussed in Section [[dimensions]].

*** TODO: Issue 7: Zero Length

The following specs, in context of a ttype ([[ttype]])
for convenience, are legal in the ASDL
grammar.[fn:grammar-snapshot] The meaning is
**unspecified**:

\vskip 0.26cm
#+begin_src clojure :eval never
  (Integer 4 [[0]])
  (Integer 4 [[6 0]])
#+end_src

See Issue 7 in MASR's GitHub repo.[fn:issue7:
https://github.com/rebcabin/masr/issues/7]

*** TODO: Issue 5: Unspecified Starting Index

If there is only 1 nat, the starting index is
unspecified. In most programming languages, the
default is 0. In Fortran and Mathematica
(Wolframscript[fn::
https://www.wolfram.com/wolframscript/]), the
default is 1. We provisionally adopt that convention
while the issue is open. See Issue 5 in MASR's
GitHub repo.[fn::
https://github.com/rebcabin/masr/issues/5]

*** FullForm

The following tests illustrate the full form for
/dimension/:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (s/valid? ::asr-term
             {::term ::dimension
              ::dimension-content [6 60]}) := true
   (s/valid? ::asr-term
             {::term ::dimension
              ::dimension-content [0]})    := true
   (s/valid? ::asr-term
             {::term ::dimension
              ::dimension-content []})     := true)
#+end_src

*** Sugar

The following tests illustrate the syntactic sugar
for /dimension/:

\vskip 0.26cm
#+begin_src clojure :eval never
  (tests
   (s/conform ::asr-term
              {::term  ::dimension,
               ::dimension-content '(1 60)}) :=
   (dimension '(1 60))
   (s/valid? ::asr-term (dimension  60))            := false
   (s/valid? ::asr-term (dimension [[]]))           := false
   (s/valid? ::asr-term (dimension 'foobar))        := false
   (s/valid? ::asr-term (dimension ['foobar]))      := false
   ;; throw arity (s/valid? ::asr-term (dimension)) := false
   (s/valid? ::asr-term (dimension []))             := true
   (s/valid? ::asr-term (dimension [60]))           := true
   (s/valid? ::asr-term (dimension [0]))            := true
   (s/valid? ::asr-term (dimension '(1 60)))        := true
   (s/valid? ::asr-term (dimension '()))            := true)
#+end_src


\clearpage
** alloc_arg
** attribute
** attribute_arg
** call_arg
** tbind
** array_index
** do_loop_head
** case_stmt
** type_stmt
** enumtype

* Implicit Terms

Terms used, explicitly or implicitly,  but not defined in ASDL.

Some items specified in ASDL as /symbol_table/ are actually
/symtab_id/.

** symtab_id
** symbol_table

* Change Log

2023-06-Apr :: Start.

2023-12-Apr :: enum-like specs
